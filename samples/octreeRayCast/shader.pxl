//----------------------------------------------------------------------------------------------------------------------
// Basic shader
//----------------------------------------------------------------------------------------------------------------------
// Pixel
//varying vec3 vPos;

uniform vec2 	uResolution;
uniform float	uTime;

float sphereDistance(vec3 _p, vec3 _center, float _rad) {
	vec3 relPos = _p - _center;
	float rad = sqrt(dot(relPos, relPos));
	float t = rad - _rad;
	return t;
}

float planeDistance(vec3 _p, float _h) {
	return _p.y - _h;
}

float torusDistance(vec3 _p, vec3 _center, vec2 _rad) {
	float c = cos(1*_p.y);
    float s = sin(1*_p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = _p;//vec3(m*_p.xz,_p.y);
	
	vec3 relPos = q - _center;
	vec2 qp = vec2(length(relPos.xz)-_rad.x,relPos.y);
	return length(qp)-_rad.y;
}

int Iterations = 5;
float Bailout = 0.5; 
int Power = 8;

float DE(vec3 pos) {
	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
	for (int i = 0; i < Iterations ; i++) {
		r = length(z);
		if (r>Bailout) break;
		
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan(z.y,z.x);
		dr = pow( r, Power-1.0)*Power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow( r,Power);
		theta = theta*Power;
		phi = phi*Power;
		
		// convert back to cartesian coordinates
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return 0.5*log(r)*r/dr;
}
/*
float DE(vec3 _p) {
	float t0 = sphereDistance(_p, vec3(0.0,6.0,7.0), 1.0);
	float t1 = 100;
	float t2 = planeDistance(_p, 0.0);
	float t3 = torusDistance(_p, vec3(0.0,4.0,7.0), vec2(2.0,1.0));
	return min(min(t0, t1),min(t2,t3));
}*/

int MaxRaySteps = 50;
float minStep = 0.001;
float MinimumDistance = 0.0001;

bool trace(vec3 from, vec3 direction, out float totalDistance, out int steps) {
	totalDistance = 0.0;
	steps;
	for (steps=0; steps < MaxRaySteps; steps++) {
		vec3 p = from + totalDistance * direction;
		float distance = DE(p);
		if (distance < MinimumDistance)
			return true;
		totalDistance += max(minStep,distance);
	}
	return false;
}

float e = 0.001;
vec3 xDir = vec3(e,0.0,0.0);
vec3 yDir = vec3(0.0,e,0.0);
vec3 zDir = vec3(0.0,0.0,e);

vec3 surfNormal(vec3 pos) {
	vec3 n = normalize(vec3(DE(pos+xDir)-DE(pos-xDir),
		                DE(pos+yDir)-DE(pos-yDir),
		                DE(pos+zDir)-DE(pos-zDir)));
	return n;
}

void main (void) {
	vec2 uv = (gl_FragCoord.xy/uResolution.xy) * vec2(uResolution.x/uResolution.y,1.0);
	
	vec3 ro = vec3(0.0, 0.0, -2.0);
	vec3 rd = normalize( vec3(-1.0+2.0*uv, 1.0) );
	
	float distance;
	int steps;
	float light = 0.0;
	//if(
	trace(ro, rd, distance, steps);//) {
		//vec3 collision = ro+rd*distance;
		//vec3 lightDir = normalize(vec3(4.0,-2.0,3.0));
		//light = max(0.2, -dot(surfNormal(collision), lightDir));
		//light *= 0.5+0.5*(1.0-float(steps)/float(MaxRaySteps));
		light = 1.0-float(steps)/float(MaxRaySteps);
	//}
	
	vec3 color = vec3(light);
	gl_FragColor = vec4(color, 0.0);
}