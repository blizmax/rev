//----------------------------------------------------------------------------------------------------------------------
// Basic shader
//----------------------------------------------------------------------------------------------------------------------
// Pixel
//varying vec3 vPos;

uniform vec2 	uResolution;
uniform vec3	uCamPos;
uniform float	uTime;
varying vec2	vUV;
uniform sampler2D uXor;

vec4 sph1 = vec4(0.0, 1.0, 7.0, 1.2);
vec4 sph2 = vec4(0.0, 3.0, 5.0, 1.2);
vec3 box1 = vec3(1.0);
vec3 box1Pos = vec3(0.0, 1.0, 4.0);

// ---------------- Noise ------------------------
float hash( vec2 p ) {
	float h = dot(p,vec2(127.1,311.7));	
    return fract(sin(h)*43758.5453123);
}
float noise1d( in vec2 p ) {
    vec2 i = floor( p );
    vec2 f = fract( p );	
	vec2 u = f*f*(3.0-2.0*f);
    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), 
                     hash( i + vec2(1.0,0.0) ), u.x),
                mix( hash( i + vec2(0.0,1.0) ), 
                     hash( i + vec2(1.0,1.0) ), u.x), u.y);
}

vec2 randomSeed = vec2((uResolution.x*vUV.x)+uTime,uTime+(uResolution.y*vUV.y));

float random1f() {
	float f = noise1d( randomSeed );
	randomSeed.x = hash(randomSeed);
	randomSeed.y = f;
	return f;
}

vec2 random2f() {
	float x = random1f();
	float y = random1f();
	return vec2(x,y);
}

//---------------- Geometry ---------------------
float iSphere(in vec3 r0, in vec3 rd, in vec4 sph) {
	vec3 relPos = r0 - sph.xyz;
	float b = 2.0*dot(relPos, rd);
	float c = dot(relPos,relPos) - sph.w*sph.w;
	float h = b*b - 4.0*c;
	if(h < 0.0)
		return -1.0;
	float t = (-b -sqrt(h))/2.0;
	if(t < 0.0)
	t = (-b + sqrt(h))/2.0;
	return t;
}

float nSphere(in vec3 _pos, in vec4 _sph) {
	return (_pos-_sph.xyz)/_sph.w;
}

float iPlane(in vec3 r0, in vec3 rd) {
	return -r0.y/rd.y;// + noise1d(r0.xy);
}

vec3 nPlane() {
	return vec3(0.0, 1.0, 0.0);
}

// --------- Distance fields -------------------------
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

float map( in vec3 p )
{
    return sdBox(p-box1Pos,box1);
}

int MaxRaySteps = 30;
float MinimumDistance = 0.01;
float minStep = 0.02;
float iiRaymarch(vec3 _r0, vec3 _rd) {
	float t = 0.0;
	int steps;
	for (steps=0; steps < MaxRaySteps; steps++) {
		float h = map(_r0 + _rd*t);
		if (h < MinimumDistance) 
			return t;
		h = max(minStep,h);
		t += h;
	}
	return -1.0;
}

float iRaymarch(in vec3 _r0, in vec3 _rd) {
	for(float t=0.0; t<100.0; )
    {
        float h = map(_r0 + _rd*t);
        if( h<MinimumDistance )
            return t;
        t += max(h,minStep);
    }
    return -1.0;
}

vec3 nRaymarch(in vec3 _r0) {
	vec2 e = vec2(0.001, 0.0);
	float d = map(_r0);
	vec3 n = vec3(d-map(_r0-e.xyy),
                  d-map(_r0-e.yxy),
                  d-map(_r0-e.yyx));
    return normalize(n);
}

// ----------------- Background ----------------------------
vec3 background(in vec3 _rd) {
	return vec3(0.0, 0.5, 1.0);
}

// ----------------- World intersection --------------------
int worldIntersect(in vec3 _r0, in vec3 _rd, out float _t) {
	int id = 0; // Invalid id
	_t = 100000.0;
	//float tS = iRaymarch(_r0, _rd);
	float tS = iSphere(_r0, _rd, sph1);
	if(tS > 0.0) {
		id = 1;
		_t = tS;
	}
	float tS2 = iSphere(_r0, _rd, sph2);
	if(tS2 > 0.0 && tS2 < _t) {
		id = 3;
		_t = tS2;
	}
	float tP = iPlane(_r0, _rd);
	if(tP > 0.0 && tP < _t)
	{
		id = 2;
		_t = tP;
	}
	return id;
}

// ----------------- World intersection --------------------
vec3 worldNormal(vec3 _r0, int _id) {
	if(_id == 1)
		return nSphere(_r0, sph1);
		//return nRaymarch(_r0);
	if(_id == 2)
		return nPlane();
	if(_id == 3)
		return nSphere(_r0, sph2);
	return vec3(1.0,0.0,0.0);
}

//------------------ World color --------------------------
vec3 worldColor(vec3 _pos, int _id) {
	if(_id == 1)
		return vec3(0.5, 0.5, 0.5);
	if(_id == 2)
		return vec3(0.2,0.15,0.1);
	if(_id == 3)
		return vec3(0.9, 0.05, 0.05);
	return vec3(1.0);
}

//---------------- Actual raytracing ----------------------
float worldShadow(in vec3 _r0, in vec3 _rd, int _self ) {
	float t;
	// Avoid noise by getting a bit above the surface
	vec3 offset = 0.00001*worldNormal(_r0, _self);
	if(0==worldIntersect(_r0+offset,_rd,t))
		return 1.0; // No intersection, hence light
	return 0.0; // Hit something, darkness
}

// ------------ Light from direct sources ------------------
vec3 worldLight(in vec3 _pos, in vec3 _normal, in int _id) {
	// Sample sun
	vec3 lightDir = normalize(vec3(4.0,-6.0,3.0));
	float light = sqrt(max(0.0,dot(_normal,-lightDir)));
	light *= worldShadow(_pos, -lightDir, _id);
	return light*vec3(1.0,1.0,0.8);
}

// ------------- Compute reflections -----------------------
vec3 brdfRay(in vec3 _n, in vec3 _r, in int id, in vec2 _rnd) {
	//vec3 tangent = cross(_n,_r);
	//vec3 bitangent = cross(_n,tangent);
	float projection = dot(_r,_n);
	//vec3 offset = tangent*_rnd.x+bitangent*_rnd.y;
	//if(id == 1)
	//	offset *= 0.7;
	return normalize(_r - 2.0*projection*_n);//+offset);
}

vec3 rayColor(in vec3 r0,in vec3 rd, in int _steps, in vec2 _rnd) {
	vec3 totalCol = vec3(0.0);
	vec3 rayCol = vec3(1.0);
	
	for(int i = 0; i < _steps; ++i) {
		// Intersect world
		float t;
		int id = worldIntersect(r0, rd, t);
		if(0 == id) { // No more intersections, go to background
			totalCol += background(rd)*rayCol;
			break;
		} else {
			// Object intersected, modulate light
			vec3 pxlPos = r0+rd*t;
			vec3 normal = worldNormal(pxlPos, id);
			
			// Modulate ray with surface color
			rayCol*=worldColor(pxlPos, id);
			
			// Compute direct light contribution
			vec3 dLight = worldLight(pxlPos, normal, id);
			totalCol += rayCol*dLight;
			
			// Prepare next iteration
			r0 = pxlPos+normal*0.001; // Avoid in-surface errors
			rd = brdfRay(normal, rd, id, _rnd);
		}
	}
	
	return totalCol;
}

void main (void) {
	vec2 uvRatio = vec2(uResolution.x/uResolution.y,1.0);
	
	sph1.x = sin(uTime);
	sph1.z = cos(uTime);
	
	int nRays = 8;
	vec3 color = vec3(0.0);
	for(int i = 0; i < nRays; ++i) {
		vec3 r0 = uCamPos;
		vec2 rnd = random2f();
		vec2 pxlOffset = rnd/uResolution;
		vec2 pxlCoord = vUV+pxlOffset;
		vec3 rd = normalize( vec3((2.0*pxlCoord-1.0)*uvRatio, 2.0) );
		
		int nSteps = 5;
		
		sph1.x = sin(3*uTime+0.1*rnd.x);
		sph1.z = cos(3*uTime+0.1*rnd.x);
		color += rayColor(r0, rd, nSteps, rnd);
	}
	color /= nRays;
	color = texture(uXor, vUV).rga;//vec3(1.0);
	gl_FragColor = vec4(color, 0.0);
}