//----------------------------------------------------------------------------------------------------------------------
// Basic shader
//----------------------------------------------------------------------------------------------------------------------
// Pixel
//varying vec3 vPos;

uniform vec2 	uResolution;
uniform vec3	uCamPos;
uniform float	uTime;
varying vec2	vUV;

vec4 sph1 = vec4(0.0, 1.0, 4.0, 1.0);

//---------------- Geometry ---------------------
float iSphere(in vec3 r0, in vec3 rd, in vec4 sph) {
	vec3 relPos = r0 - sph.xyz;
	float b = 2.0*dot(relPos, rd);
	float c = dot(relPos,relPos) - sph.w*sph.w;
	float h = b*b - 4.0*c;
	if(h < 0.0)
		return -1.0;
	float t = (-b -sqrt(h))/2.0;
	if(t < 0.0)
	t = (-b + sqrt(h))/2.0;
	return t;
}

float nSphere(in vec3 _pos, in vec4 _sph) {
	return (_pos-_sph.xyz)/_sph.w;
}

float iPlane(in vec3 r0, in vec3 rd) {
	return -r0.y/rd.y;
}

vec3 nPlane() {
	return vec3(0.0, 1.0, 0.0);
}

// ----------------- Background ----------------------------
vec3 background(in vec3 _rd) {
	return vec3(0.9, 0.9, 1.0);
}

// ----------------- World intersection --------------------
int worldIntersect(in vec3 _r0, in vec3 _rd, out float _t) {
	int id = 0; // Invalid id
	_t = 100000.0;
	float tS = iSphere(_r0, _rd, sph1);
	if(tS > 0.0) {
		id = 1;
		_t = tS;
	}
	float tP = iPlane(_r0, _rd);
	if(tP > 0.0 && tP < _t)
	{
		id = 2;
		_t = tP;
	}
	return id;
}

// ----------------- World intersection --------------------
vec3 worldNormal(vec3 _pos, int _id) {
	if(_id == 1)
		return nSphere(_pos, sph1);
	if(_id == 2)
		return nPlane();
	return vec3(1.0,0.0,0.0);
}

//------------------ World color --------------------------
vec3 worldColor(vec3 _pos, int _id) {
	if(_id == 1)
		return vec3(0.9, 0.9, 0.9);
	if(_id == 2)
		return vec3(0.2,0.2,0.2);;
	return vec3(1.0);
}

//---------------- Actual raytracing ----------------------
float worldShadow(in vec3 _r0, in vec3 _rd, int _self ) {
	float t;
	// Avoid noise by getting a bit above the surface
	vec3 offset = 0.00001*worldNormal(_r0, _self);
	if(0==worldIntersect(_r0+offset,_rd,t))
		return 1.0; // No intersection, hence light
	return 0.0; // Hit something, darkness
}

// ------------ Light from direct sources ------------------
vec3 worldLight(in vec3 _pos, in vec3 _normal, in int _id) {
	vec3 lightDir = normalize(vec3(4.0,-2.0,3.0));
	float light = sqrt(max(0.0,dot(_normal,-lightDir)));
	light *= worldShadow(_pos, -lightDir, _id);
	return vec3(light);
}

// ------------- Compute reflections -----------------------
vec3 brdfRay(in vec3 _n, in vec3 _r) {
	float projection = dot(_r,_n);
	return _r - 2.0*projection*_n;
}

vec3 rayColor(in vec3 r0,in vec3 rd, in int _steps) {
	vec3 totalCol = vec3(0.0);
	vec3 rayCol = vec3(1.0);
	
	for(int i = 0; i < _steps; ++i) {
		// Intersect world
		float t;
		int id = worldIntersect(r0, rd, t);
		if(0 == id) { // No more intersections, go to background
			totalCol += background(rd)*rayCol;
			break;
		} else {
			// Object intersected, modulate light
			vec3 pxlPos = r0+rd*t;
			vec3 normal = worldNormal(pxlPos, id);
			
			// Modulate ray with surface color
			rayCol*=worldColor(pxlPos, id);
			
			// Compute direct light contribution
			vec3 dLight = worldLight(pxlPos, normal, id);
			totalCol += rayCol*dLight;
			
			// Prepare next iteration
			r0 = pxlPos+normal*0.001; // Avoid in-surface errors
			rd = brdfRay(normal, rd);
		}
	}
	
	return totalCol;
}

void main (void) {
	vec2 uvRatio = vec2(uResolution.x/uResolution.y,1.0);
	
	sph1.x = sin(uTime);
	sph1.z = 4.0+cos(uTime);
	
	vec3 r0 = uCamPos;
	vec3 rd = normalize( vec3((2.0*vUV-1.0)*uvRatio, 2.0) );
	
	int nSteps = 5;
	vec3 color = rayColor(r0, rd, nSteps);
	
	gl_FragColor = vec4(color, 0.0);
}