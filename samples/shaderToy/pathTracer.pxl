//----------------------------------------------------------------------------------------------------------------------
// Basic shader
//----------------------------------------------------------------------------------------------------------------------
// Pixel
//varying vec3 vPos;

uniform vec2 	uResolution;
uniform vec3	uCamPos;
uniform float	uTime;
varying vec2	vUV;

vec4 sph1 = vec4(0.0, 1.0, 4.0, 1.0);

//---------------- Geometry ---------------------
float iSphere(in vec3 r0, in vec3 rd, in vec4 sph) {
	vec3 relPos = r0 - sph.xyz;
	float b = 2.0*dot(relPos, rd);
	float c = dot(relPos,relPos) - sph.w*sph.w;
	float h = b*b - 4.0*c;
	if(h < 0.0)
		return -1.0;
	float t = (-b -sqrt(h))/2.0;
	if(t < 0.0)
	t = (-b + sqrt(h))/2.0;
	return t;
}

float nSphere(in vec3 _pos, in vec4 _sph) {
	return (_pos-_sph.xyz)/_sph.w;
}

float iPlane(in vec3 r0, in vec3 rd) {
	return -r0.y/rd.y;
}

vec3 nPlane() {
	return vec3(0.0, 1.0, 0.0);
}

// ----------------- World intersection --------------------
int worldIntersect(in vec3 _r0, in vec3 _rd, out float _t) {
	int id = 0; // Invalid id
	_t = 100000.0;
	float tS = iSphere(_r0, _rd, sph1);
	if(tS > 0.0) {
		id = 1;
		_t = tS;
	}
	float tP = iPlane(_r0, _rd);
	if(tP > 0.0 && tP < _t)
	{
		id = 2;
		_t = tP;
	}
	return id;
}

vec3 worldNormal(vec3 _pos, int _id) {
	if(_id == 1)
		return nSphere(_pos, sph1);
	if(_id == 2)
		return nPlane();
	return vec3(1.0);
}

//---------------- Actual raytracing ----------------------
float worldShadow(in vec3 _r0, in vec3 _rd ) {
	float t;
	if(0==worldIntersect(_r0,_rd,t))
		return 1.0; // No intersection, hence light
	return 0.0; // Hit something, darkness
}

void main (void) {
	vec2 uvRatio = vec2(uResolution.x/uResolution.y,1.0);
	
	//sph1.x = sin(uTime);
	//sph1.z = 4.0+cos(uTime);
	
	vec3 r0 = uCamPos;
	vec3 rd = normalize( vec3((2.0*vUV-1.0)*uvRatio, 2.0) );
	
	vec3 color = vec3(0.5, 0.8, 1.0);
	vec3 lightDir = normalize(vec3(4.0,-2.0,3.0));
	float t;
	int id = worldIntersect(r0, rd, t);
	if(id != 0) {
		vec3 pxlPos = r0+rd*t;
		vec3 normal = worldNormal(pxlPos, id);
		float light = sqrt(dot(normal,-lightDir));
		color = vec3(light);
	}
	gl_FragColor = vec4(color, 0.0);
}