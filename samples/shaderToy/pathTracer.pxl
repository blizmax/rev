//----------------------------------------------------------------------------------------------------------------------
// Basic shader
//----------------------------------------------------------------------------------------------------------------------
// Pixel
//varying vec3 vPos;

uniform vec2 	uResolution;
uniform vec3	uCamPos;
uniform float	uTime;
varying vec2	vUV;

vec4 sph1 = vec4(0.0, 0.0, 4.0, 1.0);

//---------------- World intersection ---------------------
float sphere(in vec3 r0, in vec3 rd, in vec4 sph) {
	vec3 relPos = r0 - sph.xyz;
	float b = 2.0*dot(relPos, rd);
	float c = dot(relPos,relPos) - sph.w*sph.w;
	float h = b*b - 4.0*c;
	if(h < 0.0)
		return -1.0;
	float t = (-b -sqrt(h))/2.0;
	if(t < 0.0)
	t = (-b + sqrt(h))/2.0;
	return t;
}

float worldIntersect(in vec3 r0, in vec3 rd, out float _t) {
	float id = 0.0; // Invalid id
	_t = sphere(r0,rd, sph1);
	if(_t > 0.1) {
		id = 1.0;
	}
	return id;
}

//---------------- Actual raytracing ----------------------
float worldShadow(in vec3 r0, in vec3 rd ) {
	float t;
	float id = worldIntersect(r0,rd,t);
	return (id==0.0)?1.0:0.0; // Return light if no object was found
}

void main (void) {
	vec2 uvRatio = vec2(uResolution.x/uResolution.y,1.0);
	
	vec3 r0 = uCamPos;
	vec3 rd = normalize( vec3((2.0*vUV-1.0)*uvRatio, 1.0) );
	
	vec3 color = vec3(0.5, 0.8, 1.0);
	vec3 lightDir = normalize(vec3(4.0,-2.0,3.0));
	float t;
	float id = worldIntersect(r0, rd, t);
	if(id != 0.0) {
		vec3 pxlPos = r0+rd*t;//+vec3(0.0,-0.1,0.0);
		vec3 normal = pxlPos-sph1.xyz;
		color = vec3(1.0);
		if(worldShadow(pxlPos, -lightDir) == 0.0)
			color = vec3(0.5);
		//else color = vec3(0.0);
	}
	//color = vec3(vUV, 0.0);
	gl_FragColor = vec4(color, 0.0);
}