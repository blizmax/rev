#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(location = 0) in vec3 vNormal;
layout(location = 1) in vec3 vViewDir;

layout(location = 0) out vec4 outColor;

layout(push_constant) uniform UniformBufferObject {
	mat4 worldMtx;
	vec4 lightDir;
	vec4 lightClr;
	vec4 viewPos; // In model space
};

// Constants
vec3 cyan = vec3(141.0/255.0, 252.0/255.0, 247.0/255.0);
vec3 albedo = vec3(1.0, 1.0, 1.0);

float roughness = 1.0;
float metalness = 0.0;

float PI = 3.14159265359;

float DistributionGGX(float ndh, float a)
{
    float a2     = max(0.01,a*a);
    float ndh2 = ndh*ndh;
	
    float nom    = a2;
    float denom  = (ndh2 * (a2 - 1.0) + 1.0);
    denom        = PI * denom * denom;
	
    return nom / denom;
}

vec2 GeometrySchlickGGX(vec2 ndv, float k)
{
    vec2 nom   = ndv;
    vec2 denom = ndv * (1.0 - k) + k;
	
    return nom / denom;
}
  
float GeometrySmith(float ndv, float ndl, float roughness)
{
	float r = roughness+1.0;
	float k = r*r / 8.0;
    vec2 ggx = GeometrySchlickGGX(vec2(ndv,ndl), k);
	
    return ggx.x * ggx.y;
}

vec3 fresnelSchlick(float ndv, vec3 F0)
{
	float oneMinusNdV = 1.0 - ndv;
	float p2 = oneMinusNdV * oneMinusNdV;
	float p3 = oneMinusNdV * p2;
    return F0 + (1.0 - F0) * p3*p2;
}

void main() {
	// Tint reflections for metals
	vec3 F0 = mix(vec3(0.001), albedo, metalness);
	//// BRDF params
	vec3 viewDir = normalize(vViewDir);
	vec3 normal = normalize(vNormal);
	vec3 halfV = normalize(lightDir.xyz + viewDir);
	float ndh = max(0.0, dot(halfV, normal));
	float ndl = max(0.0, dot(lightDir.xyz, normal));
	float ndv = max(0.0, dot(viewDir, normal));
	// Specular
	vec3 Fs = fresnelSchlick(ndv, F0);
	float NDF = DistributionGGX(ndh, roughness);
	float G = GeometrySmith(ndv, ndl, roughness);
	
	vec3 kS = Fs;
	vec3 kD = vec3(1.0)-kS;
	kD *= 1-metalness;
	
	vec3 nom = NDF * G * Fs;
	float den = max(4.0 * ndv * ndl, 0.001);
	vec3 spec = nom / den;
	vec3 L0 = (kD*albedo / PI + spec) * lightClr.xyz *ndl;
	
	vec3 reflDir = reflect(viewDir, normal);
	vec3 ambient = cyan*0.2;
	
	vec3 indirect = ambient*kD;
	
    outColor = vec4(L0+indirect, 1.0);
}