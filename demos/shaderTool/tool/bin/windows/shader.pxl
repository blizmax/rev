// Raymarching example
uniform float time;
varying vec2 vCoord;
varying vec3 vViewDir;
varying vec3 viewPos;

const int nIterations = 75;
const float tolerance = 0.01;
const float minStep = 0.05;
const float fogMaxDistance = 10.0;

const vec3 fogColor = vec3(0.8, 0.8, 0.8);

//------------------------------------------------------
float boxDistance(in vec3 _pos, in vec3 _center, in vec3 _size)
{
	return 0.0;
}

//------------------------------------------------------
float planeDistance(in vec3 _pos)
{
	return _pos.z;
}

//------------------------------------------------------
float sphereDistance(in vec3 _pos,
					 in vec3 _center,
					 in float _rad)
{
	vec3 relPos = _pos - _center;
	return sqrt(dot(relPos,relPos)) - _rad;
}

//------------------------------------------------------
float sceneDistance(in vec3 _pos)
{
	float distP = planeDistance(_pos);
	float distS = sphereDistance(_pos,
					vec3(0.0, 10.0, 1.0 + 4.0*sin(time)),
					3.0);
	return min(distS, distP);
}

//------------------------------------------------------
int sphereTrace(in vec3 _pos, in vec3 _dir,
				out float _t)
{
	vec3 pos;
	_t = 0.0;
	int i = 0;
	for(;i < nIterations ; ++i)
	{
		pos = _pos + _t * _dir;
		//if(pos.z < tolerance)
		//	return i;
		float d = sceneDistance(pos);
		if(d <= tolerance)
			return i;
		if(d < minStep)
			d = minStep;
		_t += d;
	}
	return -1;
}

//------------------------------------------------------
vec3 raymarch(in vec3 _pos, in vec3 _dir)
{
	vec3 color = fogColor;// vec3(0.72,0.65,0.95); // Sky
	float distance;
	int res = sphereTrace(_pos, _dir, distance);
	if(res > 0 && distance < fogMaxDistance)
	{
		float iters = float(res);
		float intensity = (nIterations - iters)/nIterations;
		color = vec3(1.0, 1.0, 1.0) * intensity * intensity;
	}
	return color;
}

//------------------------------------------------------
void main (void)
{
	vec3 viewDir = normalize(vViewDir);
	vec3 color = raymarch(viewPos, viewDir);
	gl_FragColor = vec4(color, 1.0);
}