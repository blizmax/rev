// Sky.pxl

//#define DISABLE_HDR
//#define DISABLE_ATMOSPHERICS

/*const int subSamples = 5;
const int samples = 20;

const float sunIntensity = 50.0;
const vec3 sunColor = vec3(sunIntensity);

// Scattering coefficients
const vec3 wavelenFactor = vec3(1.0, 2.779, 4.883); // Computed from rgb average wavelengths

// --- Config params ---
const float rayC = 0.45;
const float mieC = 0.0;
const float absC = 0.0;
const float g = -0.85;

const vec3 outScatteringFactor = vec3(mieC)+wavelenFactor*rayC;

vec3 rayContrib(vec2 point)
{
	vec2 sDir = {sqrt(sunDir.y*sunDir.y+sunDir.x*sunDir.x), sunDir.z};
	float D = distanceToSpace(point, sDir); // Ray along sun direction
	float d = D / (subSamples+1);
	
	// Integrate air density along the ray
	float accum = 0.0;
	float dens0 = atmosphereDensity(point);
	float dens1 = 0.0;
	for(int i = 0; i < subSamples; ++i) // Note: this loop can get greatly optimized
	{
		dens1 = atmosphereDensity(point + (i+1)*d*sDir);
		accum += 0.5*d*(dens0+dens1);
		dens0 = dens1;
	}
	accum+= 0.5 * d * dens0;
	
	vec3 incident = (outScatteringFactor+vec3(absC))*accum;
	
	float e = 2.71;
	return vec3(pow(e,-incident.x),pow(e,-incident.y),pow(e,-incident.z));
}

vec4 surfaceColor()
{
	// Calculate ray direction
	vec2 uv = vec2(2.0*vTex0.x-1.0, 1.5*vTex0.y-0.75);
	vec3 viewDir = normalize(vec3(uv.x,1.0,uv.y)); // fov=45deg
	vec2 camPos = vec2(0.0,viewPos.z+EarthRadius);
	
	//--------------------------------------
	vec2 vDir = { sqrt(viewDir.x*viewDir.x+viewDir.y*viewDir.y), viewDir.z};
	float viewDistance = distanceToSpace(camPos, vDir);
	float d = viewDistance/(samples+1);
	
	vec3 accumLight = vec3(0.0);
	float accumDensity = 0;
		
	float cosTheta = dot(viewDir,-sunDir);
	float rPhase = rayPhase(cosTheta);
	float mPhase = miePhase(cosTheta);
	float density0 = atmosphereDensity(camPos);

	vec3 totalPhase = vec3(mieC*mPhase) + wavelenFactor*(rayC*rPhase);
	vec3 light0 = totalPhase * sunColor * rayContrib(camPos); // No extintion
	float density1;
	vec3 light1;
	
	for(int i = 0; i < samples; ++i)
	{
		vec2 p = camPos + d * vDir;
		// Integrate atmosphere density
		density1 = atmosphereDensity(p);
		accumDensity += 0.5*d*(density1+density0);
		density0 = density1;
		// Compute extintion factors
		float e = 2.71;
		vec3 extFac = -(outScatteringFactor+vec3(absC))*accumDensity;
		vec3 extintion = vec3(pow(e,extFac.x),pow(e,extFac.y),pow(e,extFac.z));
		// Light contribution
		vec3 contrib = rayContrib(p);
		light1 = extintion * totalPhase * sunColor * contrib;
		
		accumLight += 0.5 * d * (light1+light0);
		light0 = light1;
	}
	accumLight += 0.5 * d * light0;
	
	//--------------------------------------
	vec3 color = rayContrib(camPos) * 1.0;//accumLight;
	return vec4(color,1.0);
}*/

#define OVERRIDE_ATMOSPHERICS
vec3 sunContribution(in vec2 point)
{
	// vec2 lDir = {length(light0Dir.xy), light0Dir.z};
	// float extintionExp = 0.10;// distanceToSpace(point, lDir);
	// vec3 extBeta = vec3(lAbC)+rayC*invWavelen4;
	// return vec3(pow(e, -extBeta.x*extintionExp),
	// 					pow(e, -extBeta.y*extintionExp),
	// 					pow(e, -extBeta.z*extintionExp));
	return vec3(1.0);
}

vec3 applyAtmospherics(in vec3 color)
{
	vec2 uv = vec2(2.0*vTex0.x-1.0, 1.5*vTex0.y-0.75);
	vec3 rayDir = normalize(vec3(uv.x,1.0,uv.y)); // fov=45deg
	vec2 camPos = vec2(0.0,viewPos.z+EarthRadius);
	// Proyected position and ray
	vec2 cPos = {0.0, viewPos.z+EarthRadius}; // 2D camera position
	vec2 vRay = {length(rayDir.xy),rayDir.z};
	float rayLength = distanceToSpace(cPos, vRay);
	
	// Scattering loop
	// Scattering phases
	float cosTheta = dot(normalize(rayDir),-light0Dir);
	float ray = rayleighPhase(cosTheta);
	float mie = miePhase(cosTheta);
	vec3 scBeta = rayC * ray * invWavelen4 + vec3(mieC*mie);
	vec3 extBeta = vec3(lAbC)+scBeta;
	
	// Scattering loop
	vec3 rayColor = vec3(0.0);
	float extintionExp = 0.0;
	float dens0 = atmosphereDensity(cPos);
	float dens1;
	vec3 color0 = sunContribution(cPos);
	vec3 color1;
	float deltaD = rayLength/(scatteringSamples+1);
	for(int i = 0; i < scatteringSamples+1; ++i)
	{
		// compute new sample
		vec2 samplePos = cPos+vRay*deltaD*(i+1);
		
		// Integrate density
		dens1 = atmosphereDensity(samplePos);
		extintionExp += deltaD*(dens1+dens0)*0.5;
		dens0 = dens1;
		// Compute extintion
		vec3 extintion = vec3(pow(e, -extBeta.x*extintionExp),
						pow(e, -extBeta.y*extintionExp),
						pow(e, -extBeta.z*extintionExp));
		
		// Integrate contribution
		color1 = extintion*sunContribution(samplePos);
		rayColor += 0.5*deltaD*(color1+color0);
		color0 = color1;
	}
	
	return color+scBeta*rayColor;
}

vec4 surfaceColor()
{
return vec4(applyAtmospherics(vec3(0.0, 0.0, 0.0)), 1.0);
}